<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapLibre OSM Map with Polygon Markers</title>
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.7/dist/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/dist/tippy.css" />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/themes/light.css" />
  
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RGB500YVSX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-RGB500YVSX');
</script>
  
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
            right: 300px; /* Adjust map width to accommodate sidebar */
        }
        .maplibregl-popup {
            max-width: 300px;
        }
        .status-pending {
            color: #e74c3c;
            font-weight: bold;
        }
        .status-completed {
            color: #e74c3c;
            font-weight: bold;
        }
        .tippy-box {
            max-width: 400px !important;
            background-color: white;
            color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .tippy-content {
            padding: 15px;
        }
        .info-card {
            border-radius: 8px;
            padding: 5px;
            font-size: 14px;
            position: relative;
        }
        .info-card h3 {
            margin-top: 5px;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            font-size: 16px;
            color: #2c3e50;
        }
        .info-card p {
            margin: 8px 0;
            line-height: 1.4;
        }
        .info-label {
            font-weight: bold;
            color: #34495e;
            display: inline-block;
            min-width: 120px;
        }
        .info-value {
            display: inline-block;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .polygon {
            cursor: pointer;
        }
        /* Close button styles */
        .close-button {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 1;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            z-index: 10;
            transition: background-color 0.2s;
        }
        .close-button:hover {
            background-color: #c0392b;
        }

        /* Sidebar styles */
        #sidebar {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: white;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
        }

        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
            transition: transform 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .card.pending {
            border-left: 4px solid #e74c3c;
        }

        .card.completed {
            border-left: 4px solid #e74c3c;
        }

        .source-link {
            display: block;
            background: #3498db;
            color: white !important;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }

        .source-link:hover {
            background: #2980b9;
            text-decoration: none !important;
        }

        @media (max-width: 768px) {
            #sidebar {
                display: none;
            }
            #map {
                right: 0;
            }
        }

        /* Collapsible card styles */
        .card {
            cursor: pointer;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .card-content {
            display: none;
            padding-top: 10px;
            border-top: 1px solid #eee;
            margin-top: 10px;
        }

        .card.expanded .card-content {
            display: block;
        }

        .card-title {
            margin: 0;
            font-size: 16px;
            color: #2c3e50;
            line-height: 1.4;
        }

        .expand-icon {
            font-size: 20px;
            color: #7f8c8d;
            transition: transform 0.3s;
            margin-left: 10px;
        }

        .card.expanded .expand-icon {
            transform: rotate(180deg);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="sidebar">
        <a href="https://docs.google.com/spreadsheets/d/1cWGBzYPa93_NZq8ZwtqF94fhwIdovrWkPg6-PRNaVHc/edit#gid=0" 
           target="_blank" 
           class="source-link">
            მონაცემთა წყარო
        </a>
        <div id="cards-container"></div>
    </div>

    <script>
        // Calculate polygon size based on zoom level with adjusted sizes
        function calculatePolygonSize(map) {
            // Get the current zoom level
            const zoom = map.getZoom();
            
            // Base size reduced by half for zoom out view
            const baseSize = 0.25; // Half of previous value (0.5)
            
            // Steeper reduction rate for zoomed in view
            const zoomFactor = Math.pow(0.5, zoom - 5);
            
            // Minimum size is 1/10 of previous minimum
            const minSize = 0.005; // 1/10 of previous value (0.05)
            // Maximum size is half of previous maximum
            const maxSize = 0.4;   // Half of previous value (0.8)
            
            // Calculate size based on zoom level with constraints
            return Math.min(maxSize, Math.max(minSize, baseSize * zoomFactor));
        }
        
        // Function to create polygon coordinates around a center point
        function createPolygonCoordinates(map, centerLng, centerLat, sides = 6) {
            // Get a much larger radius based on zoom level
            const radius = calculatePolygonSize(map);
            
            // Add random rotation between 0 and 360 degrees
            const randomRotation = Math.random() * 2 * Math.PI;
            
            const coordinates = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + randomRotation;
                const lng = centerLng + radius * Math.cos(angle);
                const lat = centerLat + radius * Math.sin(angle);
                coordinates.push([lng, lat]);
            }
            // Close the polygon by repeating the first point
            coordinates.push(coordinates[0]);
            return coordinates;
        }

        // Function to detect if a string is a URL
        function isURL(str) {
            if (!str || typeof str !== 'string') return false;
            str = str.trim();
            // Simple regex to match common URL patterns
            const urlPattern = /^(https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/i;
            return urlPattern.test(str);
        }
        
        // Create HTML content for the tooltip without making assumptions about data
        function createTooltipHTML(feature, instanceId) {
            const data = feature.properties;
            
            // Create wrapper with a close button
            let html = `<div class="info-card">
                <button class="close-button" onclick="closeTooltip(${instanceId})">✕</button>`;
            
            // Get all keys except internal ones
            const keys = Object.keys(data).filter(key => 
                !['id', 'fillColor', 'strokeColor'].includes(key)
            );
            
            // Process all fields
            for (const key of keys) {
                let value = data[key];
                
                // Only special handling for coordinates (as allowed)
                if (key === "lat" || key === "lon") {
                    value = typeof value === 'number' ? value.toFixed(4) : value;
                }
                
                // Convert URLs to links (not making assumptions, just basic URL detection)
                if (value && typeof value === 'string' && isURL(value)) {
                    value = `<a href="${value}" target="_blank">${value}</a>`;
                }
                // Handle null or undefined
                else if (value === null || value === undefined) {
                    value = "";
                }
                
                html += `<p><span class="info-label">${key}:</span> <span class="info-value">${value}</span></p>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Function to close a tooltip
        function closeTooltip(id) {
            if (window.tippyInstances && window.tippyInstances[id]) {
                window.tippyInstances[id].hide();
            }
        }

        // Initialize map after data is loaded
        d3.csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vRfK0UcHgAiwmJwTSWe2dxyIwzLFtS2150qbKVVti1uVfgDhwID3Ec6NLRrvX4AlABpxneejy1-lgTF/pub?gid=0&single=true&output=csv")
            .then(function(data) {
                // Process the loaded data
                const sampleData = data.map(d => ({
                    ...d,
                    lat: d.lat ? +d.lat : null,  // Convert to number if exists
                    lon: d.lon ? +d.lon : null   // Convert to number if exists
                }));

                // Populate sidebar cards
                const cardsContainer = document.getElementById('cards-container');
                sampleData.forEach((item, index) => {
                    const card = document.createElement('div');
                    const isPending = item["სტატუსი (მომლოდინე/ დასრულებულია)"] === "მომლოდინე";
                    card.className = `card ${isPending ? 'pending' : 'completed'}`;
                    
                    const needsTitle = item[`საჭიროება(ები)
(საკვები, მედიკამენტები, ევაკუაცია, ექიმი, საწვავი, დათოლვა, სხვა)    `];

                    // Helper function to format value as link if it's a URL
                    const formatValue = (value) => {
                        if (!value) return '-';
                        return isURL(value) ? `<a href="${value}" target="_blank">${value}</a>` : value;
                    };

                    let cardContent = `
                        <div class="card-header">
                            <h3 class="card-title">${needsTitle}</h3>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div class="card-content">
                            <p><strong>სახელი, გვარი:</strong> ${formatValue(item["სახელი, გვარი"])}</p>
                            <p><strong>რაიონი:</strong> ${formatValue(item["რაიონი"])}</p>
                            <p><strong>სოფელი:</strong> ${formatValue(item["სოფელი"])}</p>
                            <p><strong>ზუსტი ადგილმდებარეობა:</strong> ${formatValue(item["ზუსტი ადგილმდებარეობა"])}</p>
                            <p><strong>ტელეფონი:</strong> ${formatValue(item["ტელეფონი"])}</p>
                            <p><strong>დეტალური ინფორმაცია:</strong> ${formatValue(item["დეტალური ინფორმაცია"])}</p>
                            <p><strong>სტატუსი:</strong> 
                                <span class="${isPending ? 'status-pending' : 'status-completed'}">
                                    ${item["სტატუსი (მომლოდინე/ დასრულებულია)"] || '-'}
                                </span>
                            </p>
                        </div>`;

                    card.innerHTML = cardContent;

                    // Add click handlers
                    card.addEventListener('click', (e) => {
                        // Toggle expansion
                        card.classList.toggle('expanded');

                        // If has coordinates and isn't clicking to expand
                        if (item.lat && item.lon && !e.target.closest('.card-content')) {
                            map.flyTo({
                                center: [item.lon, item.lat],
                                zoom: 12
                            });
                        }
                    });

                    cardsContainer.appendChild(card);
                });

                // Initialize the map
                const map = new maplibregl.Map({
                    container: 'map',
                    style: {
                        version: 8,
                        sources: {
                            'osm': {
                                type: 'raster',
                                tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                                tileSize: 256,
                                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                            }
                        },
                        layers: [{
                            id: 'osm-tiles',
                            type: 'raster',
                            source: 'osm',
                            minzoom: 0,
                            maxzoom: 19
                        }]
                    },
                    center: [43.5, 42.0], // Center of Georgia
                    zoom: 7
                });

                // Wait for the map to load
                map.on('load', function() {
                    // Function to update features based on current zoom
                    function updateFeatures() {
                        // Create features for GeoJSON source
                        return sampleData.map((item, index) => {
                            // Get status for color
                            const isPending = item["სტატუსი (მომლოდინე/ დასრულებულია)"] === "მომლოდინე";
                            
                            // Create different polygon colors based on status
                            const fillColor = '#e74c3c';
                            const strokeColor = '#c0392b';
                            
                            return {
                                type: 'Feature',
                                properties: {
                                    id: index,
                                    ...item,
                                    fillColor: fillColor,
                                    strokeColor: strokeColor
                                },
                                geometry: {
                                    type: 'Polygon',
                                    coordinates: [createPolygonCoordinates(map, item.lon, item.lat)]
                                }
                            };
                        });
                    }
                    
                    // Initial features
                    const features = updateFeatures();

                    // Add source with features
                    map.addSource('locations', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: features
                        }
                    });

                    // Add a layer for the polygons
                    map.addLayer({
                        id: 'location-polygons',
                        type: 'fill',
                        source: 'locations',
                        paint: {
                            'fill-color': ['get', 'fillColor'],
                            'fill-opacity': 0.6
                        }
                    });

                    // Add an outline layer for the polygons
                    map.addLayer({
                        id: 'location-polygons-outline',
                        type: 'line',
                        source: 'locations',
                        paint: {
                            'line-color': ['get', 'strokeColor'],
                            'line-width': 2
                        }
                    });

                    // Make tippyInstances available globally so the close button can access it
                    window.tippyInstances = {};

                    // Add click events to polygons
                    map.on('click', 'location-polygons', function(e) {
                        if (e.features.length > 0) {
                            const feature = e.features[0];
                            const id = feature.properties.id;
                            
                            // Get click position
                            const clickX = e.point.x;
                            const clickY = e.point.y;
                            
                            // Create tooltip content with the ID for close button reference
                            const tooltipContent = document.createElement('div');
                            tooltipContent.innerHTML = createTooltipHTML(feature, id);
                            
                            // Create marker element to attach tooltip to
                            let marker = document.getElementById(`marker-${id}`);
                            if (!marker) {
                                marker = document.createElement('div');
                                marker.id = `marker-${id}`;
                                marker.style.position = 'absolute';
                                marker.style.top = `${clickY}px`;
                                marker.style.left = `${clickX}px`;
                                marker.style.width = '1px';
                                marker.style.height = '1px';
                                document.body.appendChild(marker);
                            }
                            
                            // Hide any existing tooltips first
                            Object.values(window.tippyInstances).forEach(instance => {
                                if (instance && instance.hide) {
                                    instance.hide();
                                }
                            });
                            
                            // Create tippy instance
                            setTimeout(() => {
                                // Make sure any previous instance is destroyed
                                if (window.tippyInstances[id] && window.tippyInstances[id].destroy) {
                                    window.tippyInstances[id].destroy();
                                }
                                
                                // Create new instance on the marker element
                                window.tippyInstances[id] = tippy(marker, {
                                    content: tooltipContent,
                                    allowHTML: true,
                                    interactive: true,
                                    theme: 'light',
                                    placement: 'top',
                                    trigger: 'manual',
                                    appendTo: document.body,
                                    showOnCreate: true,
                                    hideOnClick: false,
                                    interactiveBorder: 30
                                });
                                
                                // Show the tooltip
                                if (window.tippyInstances[id] && window.tippyInstances[id].show) {
                                    window.tippyInstances[id].show();
                                }
                            }, 0);
                        }
                    });

                    // Change cursor on polygon hover
                    map.on('mouseenter', 'location-polygons', function() {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    map.on('mouseleave', 'location-polygons', function() {
                        map.getCanvas().style.cursor = '';
                    });

                    // Update tooltip positions when map moves
                    map.on('move', function() {
                        Object.values(window.tippyInstances).forEach(instance => {
                            if (instance && instance.state && instance.state.isVisible) {
                                instance.hide();
                            }
                        });
                    });
                    
                    // Update polygon sizes when zoom changes
                    map.on('zoom', function() {
                        // Update features with new polygon sizes
                        const updatedFeatures = updateFeatures();
                        
                        // Update the source data
                        map.getSource('locations').setData({
                            type: 'FeatureCollection',
                            features: updatedFeatures
                        });
                    });
                });
            })
            .catch(function(error) {
                console.error("Error loading the data:", error);
            });
    </script>
</body>
</html>