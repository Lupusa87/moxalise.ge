<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>გურიის დიდთოვლობით დაზარალებული მოსახლეობის დახმარება</title>
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.7/dist/tippy-bundle.umd.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/dist/tippy.css" />
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6.3.7/themes/light.css" />
  
  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-RGB500YVSX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-RGB500YVSX');
</script>
  
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .maplibregl-popup {
            max-width: 300px;
        }
        .status-pending {
            color: #e74c3c;
            font-weight: bold;
        }
        .status-completed {
            color: #e74c3c;
            font-weight: bold;
        }
        .tippy-box {
            max-width: 400px !important;
            background-color: white;
            color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .tippy-content {
            padding: 15px;
        }
        .info-card {
            border-radius: 8px;
            padding: 5px;
            font-size: 14px;
            position: relative;
        }
        .info-card h3 {
            margin-top: 5px;
            margin-bottom: 10px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            font-size: 16px;
            color: #2c3e50;
        }
        .info-card p {
            margin: 8px 0;
            line-height: 1.4;
        }
        .info-label {
            font-weight: bold;
            color: #34495e;
            display: inline-block;
            min-width: 120px;
        }
        .info-value {
            display: inline-block;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .polygon {
            cursor: pointer;
        }
        /* Close button styles */
        .close-button {
            position: absolute;
            top: 0;
            right: 0;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            line-height: 1;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 5px;
            z-index: 10;
            transition: background-color 0.2s;
        }
        .close-button:hover {
            background-color: #c0392b;
        }

        /* Sidebar styles */
        #sidebar {
            position: fixed;
            right: 0;
            top: 0;
            bottom: 0;
            width: 300px;
            background: white;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 1000;
            padding: 20px;
        }

        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
            transition: transform 0.2s;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .card.pending {
            border-left: 4px solid #e74c3c; /* Red for pending */
        }

        .card.completed {
            border-left: 4px solid #2ecc71; /* Green for completed */
        }

        .card.empty-status {
            border-left: 4px solid #95a5a6; /* Gray for empty status */
        }

        .source-link {
            display: block;
            background: #3498db;
            color: white !important;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }

        .source-link:hover {
            background: #2980b9;
            text-decoration: none !important;
        }

        .facebook-link {
            display: block;
            background: #4267B2;
            color: white !important;
            padding: 10px 20px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
            font-weight: bold;
        }

        .facebook-link:hover {
            background: #365899;
            text-decoration: none !important;
        }

        @media (max-width: 768px) {
            #sidebar {
                display: none;
                position: fixed;
                left: 0;
                width: 100%;
                height: 100%;
                overflow-y: auto;
            }
            #map {
                right: 0;
            }
            .mobile-sidebar-button {
                display: block;
            }
            #sidebar.mobile-visible {
                display: block;
                z-index: 2000;
            }
            .tabs-panel {
                right: 0;
            }
        }

        /* Collapsible card styles */
        .card {
            cursor: pointer;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .card-content {
            display: none;
            padding-top: 10px;
            border-top: 1px solid #eee;
            margin-top: 10px;
        }

        .card.expanded .card-content {
            display: block;
        }

        .card-title {
            margin: 0;
            font-size: 16px;
            color: #2c3e50;
            line-height: 1.4;
        }

        .expand-icon {
            font-size: 20px;
            color: #7f8c8d;
            transition: transform 0.3s;
            margin-left: 10px;
        }

        .card.expanded .expand-icon {
            transform: rotate(180deg);
        }

        /* Add highlighted polygon styles */
        .highlighted-card {
            background-color: #f8d7da;
        }

        /* Bottom panel styles */
        #bottom-panel {
            position: fixed;
            left: 0;
            bottom: 0;
            height: 600px;
            background: white;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        #bottom-panel iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        .toggle-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 1001;
        }

        .toggle-panel:hover {
            background: #2980b9;
        }

        /* Adjust map height when panel is visible */
        #map.panel-visible {
            bottom: 300px;
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            line-height: 1.4;
            text-align: center;
        }

        /* Tab panel styles */
        .tabs-panel {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 600px;
            background: white;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            z-index: 1000;
            display: none;
        }

        .tabs-header {
            display: flex;
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
            justify-content: space-between;
            align-items: center;
            padding-right: 10px;
        }

        .tab-button {
            padding: 12px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            color: #495057;
            border-bottom: 2px solid transparent;
        }

        .tab-button:hover {
            color: #228be6;
        }

        .tab-button.active {
            color: #228be6;
            border-bottom-color: #228be6;
        }

        .tab-content {
            display: none;
            height: calc(100% - 45px);
        }

        .tab-content.active {
            display: block;
        }

        .tab-content iframe {
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjust map height when panel is visible */
        #map.panel-visible {
            bottom: 600px;
        }

        .redirect-button {
            display: block;
            width: 80%;
            max-width: 400px;
            padding: 30px;
            background: #e74c3c;
            color: white;
            text-align: center;
            border: none;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
        }

        .redirect-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .tabs-close {
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 15px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .tabs-close:hover {
            background: #c0392b;
        }

        /* Mobile sidebar button and panel */
        .mobile-sidebar-button {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 12px 20px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 2001; /* Increase z-index to be above everything */
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .mobile-sidebar-button:hover {
            background: #c0392b;
        }

        @media (max-width: 768px) {
            .mobile-sidebar-button {
                display: block;
            }
            #sidebar {
                display: none;
                position: fixed;
                left: 0;
                width: calc(100% - 41px);
                height: 100%;
                overflow-y: auto;
            }
            #map {
                right: 0;
            }
            .mobile-sidebar-button {
                display: block;
            }
            #sidebar.mobile-visible {
                display: block;
                z-index: 2000;
            }
            .tabs-panel {
                right: 0;
            }
        }

        .map-pin {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <button class="mobile-sidebar-button" onclick="toggleMobileSidebar()">საჭიროებების სია</button>
    <div id="sidebar">
        <h1 class="sidebar-title">გურიის დიდთოვლობით დაზარალებული მოსახლეობის დახმარება</h1>
        <a href="https://docs.google.com/spreadsheets/d/1cWGBzYPa93_NZq8ZwtqF94fhwIdovrWkPg6-PRNaVHc/edit#gid=0" 
           target="_blank" 
           class="source-link">
            მონაცემთა წყარო
        </a>
        <a href="https://www.facebook.com/groups/634781109242732" 
           target="_blank" 
           class="facebook-link">
            Facebook ჯგუფი
        </a>
        <div id="cards-container"></div>
    </div>
    <button class="toggle-panel" onclick="toggleTabs()">მონაცემების პანელი</button>
    <div class="tabs-panel" id="tabs-panel">
        <div class="tabs-header">
            <div>
                <button class="tab-button active" data-tab="spreadsheet">მონაცემების ცხრილი</button>
            </div>
            <button class="tabs-close" onclick="toggleTabs()">დახურვა</button>
        </div>
        <div class="tab-content active" id="spreadsheet">
            <iframe src="https://docs.google.com/spreadsheets/d/1cWGBzYPa93_NZq8ZwtqF94fhwIdovrWkPg6-PRNaVHc/edit?usp=sharing" allow="autoplay"></iframe>
        </div>
    </div>

    <script>
        // Add this function before other scripts
        function togglePanel() {
            const panel = document.getElementById('bottom-panel');
            const map = document.getElementById('map');
            const isHidden = panel.style.display === 'none' || !panel.style.display;
            
            panel.style.display = isHidden ? 'block' : 'none';
            map.classList.toggle('panel-visible');
            
            // Trigger map resize to ensure proper rendering
            if (window.map) {
                window.map.resize();
            }
        }

        // Calculate polygon size based on zoom level with adjusted sizes
        function calculatePolygonSize(map) {
            // Get the current zoom level
            const zoom = map.getZoom();
            
            // Base size reduced by half for zoom out view
            const baseSize = 0.25; // Half of previous value (0.5)
            
            // Steeper reduction rate for zoomed in view
            const zoomFactor = Math.pow(0.5, zoom - 5);
            
            // Minimum size is 1/10 of previous minimum
            const minSize = 0.005; // 1/10 of previous value (0.05)
            // Maximum size is half of previous maximum
            const maxSize = 0.4;   // Half of previous value (0.8)
            
            // Calculate size based on zoom level with constraints
            return Math.min(maxSize, Math.max(minSize, baseSize * zoomFactor));
        }
        
        // Function to create polygon coordinates around a center point
        function createPolygonCoordinates(map, centerLng, centerLat, sides = 6) {
            // Get a much larger radius based on zoom level
            const radius = calculatePolygonSize(map);
            
            // Use fixed rotation based on coordinates instead of random
            const fixedRotation = Math.atan2(centerLat, centerLng);
            
            const coordinates = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI) / sides + fixedRotation;
                const lng = centerLng + radius * Math.cos(angle);
                const lat = centerLat + radius * Math.sin(angle);
                coordinates.push([lng, lat]);
            }
            // Close the polygon by repeating the first point
            coordinates.push(coordinates[0]);
            return coordinates;
        }

        // Function to detect if a string is a URL
        function isURL(str) {
            if (!str || typeof str !== 'string') return false;
            str = str.trim();
            // Simple regex to match common URL patterns
            const urlPattern = /^(https?:\/\/)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/i;
            return urlPattern.test(str);
        }
        
        // Function to format values, converting URLs to links
        function formatValue(value) {
            if (!value) return '-';
            return isURL(value) ? `<a href="${value}" target="_blank">${value}</a>` : value;
        }
        
        // Create HTML content for the tooltip without making assumptions about data
        function createTooltipHTML(feature, instanceId) {
            const data = feature.properties;
            
            // Create wrapper with a close button
            let html = `<div class="info-card">
                <button class="close-button" onclick="closeTooltip(${instanceId})">✕</button>`;
            
            // Get all keys except internal ones
            const keys = Object.keys(data).filter(key => 
                !['id', 'fillColor', 'strokeColor'].includes(key)
            );
            
            // Process all fields
            for (const key of keys) {
                let value = data[key];
                
                // Only special handling for coordinates (as allowed)
                if (key === "lat" || key === "lon") {
                    value = typeof value === 'number' ? value.toFixed(4) : value;
                }
                
                // Convert URLs to links (not making assumptions, just basic URL detection)
                if (value && typeof value === 'string' && isURL(value)) {
                    value = `<a href="${value}" target="_blank">${value}</a>`;
                }
                // Handle null or undefined
                else if (value === null || value === undefined) {
                    value = "";
                }
                
                html += `<p><span class="info-label">${key}:</span> <span class="info-value">${value}</span></p>`;
            }
            
            html += `</div>`;
            return html;
        }

        // Function to close a tooltip
        function closeTooltip(id) {
            if (window.tippyInstances && window.tippyInstances[id]) {
                window.tippyInstances[id].hide();
            }
        }

        // Add highlightPolygon function before map initialization
        function highlightPolygon(map, index) {
            // Reset all polygons
            map.setPaintProperty('location-polygons', 'fill-opacity', [
                'case',
                ['==', ['get', 'id'], index],
                0.9, // highlighted opacity
                0.6  // default opacity
            ]);

            // Update stroke color and width for highlighted polygon
            map.setPaintProperty('location-polygons-outline', 'line-color', [
                'case',
                ['==', ['get', 'id'], index],
                '#000000', // black stroke for highlighted
                ['get', 'strokeColor'] // default stroke color
            ]);

            map.setPaintProperty('location-polygons-outline', 'line-width', [
                'case',
                ['==', ['get', 'id'], index],
                5,    // highlighted width
                2     // default width
            ]);

            // Remove highlight from all cards
            document.querySelectorAll('.card').forEach(c => c.classList.remove('highlighted-card'));
            // Add highlight to selected card
            document.querySelector(`.card[data-index="${index}"]`)?.classList.add('highlighted-card');
        }

        // Add this function before createPolygonCoordinates
        function calculatePointOffset(index, baseRadius) {
            // Create a spiral pattern
            const angle = index * 0.5; // Rotate each point by 0.5 radians
            const radius = baseRadius * (1 + index * 0.2); // Increase radius for each point
            return {
                x: Math.cos(angle) * radius,
                y: Math.sin(angle) * radius
            };
        }

        // Initialize map after data is loaded
        d3.csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vRfK0UcHgAiwmJwTSWe2dxyIwzLFtS2150qbKVVti1uVfgDhwID3Ec6NLRrvX4AlABpxneejy1-lgTF/pub?gid=0&single=true&output=csv")
            .then(function(data) {
                // Process the loaded data
                const sampleData = data.map(d => ({
                    ...d,
                    lat: d.lat ? +d.lat : null,  // Convert to number if exists
                    lon: d.lon ? +d.lon : null   // Convert to number if exists
                }));

                // Calculate bounds of all points
                const bounds = sampleData.reduce((bounds, item) => {
                    if (item.lat && item.lon) {
                        bounds.north = Math.max(bounds.north, item.lat);
                        bounds.south = Math.min(bounds.south, item.lat);
                        bounds.east = Math.max(bounds.east, item.lon);
                        bounds.west = Math.min(bounds.west, item.lon);
                    }
                    return bounds;
                }, { north: -90, south: 90, east: -180, west: 180 });

                // Populate sidebar cards
                const cardsContainer = document.getElementById('cards-container');
                sampleData.forEach((item, index) => {
                    const card = document.createElement('div');
                    card.setAttribute('data-index', index);
                    
                    // Determine status class
                    let statusClass = 'empty-status';
                    const status = item["სტატუსი\n(მომლოდინე/ დასრულებულია)"];
                    if (status === "მომლოდინე") {
                        statusClass = 'pending';
                    } else if (status === "აღმოუჩინეს დახმარება") {
                        statusClass = 'completed';
                    }
                    
                    card.className = `card ${statusClass}`;

                    const needsTitle = item[`საჭიროება(ები)
(საკვები, მედიკამენტები, ევაკუაცია, ექიმი, საწვავი, დათოლვა, სხვა)    `];

                    // Get first item's keys to determine structure
                    const keys = Object.keys(item).filter(key => 
                        !['id', 'fillColor', 'strokeColor', 'lat', 'lon'].includes(key)
                    );

                    let cardContent = `
                        <div class="card-header">
                            <h3 class="card-title">${needsTitle||[keys[0]] || ''}</h3>
                            <span class="expand-icon">▼</span>
                        </div>
                        <div class="card-content">
                            ${keys.slice(1).map(key => `
                                <p><strong>${key}:</strong> ${formatValue(item[key])}</p>
                            `).join('')}
                        </div>`;

                    card.innerHTML = cardContent;

                    // Add click handlers
                    card.addEventListener('click', (e) => {
                        // Toggle expansion
                        card.classList.toggle('expanded');

                        // If has coordinates and isn't clicking to expand
                        if (item.lat && item.lon && !e.target.closest('.card-content')) {
                            map.flyTo({
                                center: [item.lon, item.lat],
                                zoom: 12
                            });
                            highlightPolygon(map, index);
                        }
                    });

                    cardsContainer.appendChild(card);
                });

                // Initialize the map
                const map = new maplibregl.Map({
                    container: 'map',
                    style: {
                        version: 8,
                        sources: {
                            'osm': {
                                type: 'raster',
                                tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
                                tileSize: 256,
                                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                            }
                        },
                        layers: [{
                            id: 'osm-tiles',
                            type: 'raster',
                            source: 'osm',
                            minzoom: 0,
                            maxzoom: 19
                        }]
                    },
                    bounds: [
                        [bounds.west - 0.1, bounds.south - 0.1], // Add padding to bounds
                        [bounds.east + 0.1, bounds.north + 0.1]
                    ],
                    fitBoundsOptions: {
                        padding: 50
                    }
                });

                // Wait for the map to load
                map.on('load', function() {
                    // Create markers first and only once
                    const markers = [];
                    sampleData.forEach((item, index) => {
                        if (item.lat && item.lon && item["ზუსტი ადგილმდებარეობა"]?.trim()) {
                            let color;
                            const status = item["სტატუსი\n(მომლოდინე/ დასრულებულია)"];
                            
                            if (status === "მომლოდინე") {
                                color = '#e74c3c';  // Red
                            } else if (status === "აღმოუჩინეს დახმარება") {
                                color = '#2ecc71';  // Green
                            } else {
                                color = '#95a5a6';  // Gray
                            }

                            const el = document.createElement('div');
                            el.className = 'map-pin';
                            el.style.backgroundColor = color;
                            
                            const marker = new maplibregl.Marker({
                                element: el,
                                anchor: 'center'
                            }).setLngLat([item.lon, item.lat])
                              .addTo(map);
                                
                            markers.push({
                                marker,
                                id: index,
                                properties: item
                            });
                        }
                    });

                    // Store markers globally for later access
                    window.locationMarkers = markers;

                    // Function to update features based on current zoom
                    function updateFeatures() {
                        // Group points by location (only for non-exact locations)
                        const locationGroups = {};
                        
                        sampleData.forEach((item, index) => {
                            if (item.lat && item.lon && !item["ზუსტი ადგილმდებარეობა"]?.trim()) {
                                let color;
                                const status = item["სტატუსი\n(მომლოდინე/ დასრულებულია)"];
                                
                                if (status === "მომლოდინე") {
                                    color = '#e74c3c';
                                } else if (status === "აღმოუჩინეს დახმარება") {
                                    color = '#2ecc71';
                                } else {
                                    color = '#95a5a6';
                                }

                                const key = `${item.lat.toFixed(4)},${item.lon.toFixed(4)}`;
                                if (!locationGroups[key]) {
                                    locationGroups[key] = [];
                                }
                                locationGroups[key].push({ 
                                    item, 
                                    index,
                                    fillColor: color,
                                    strokeColor: color
                                });
                            }
                        });

                        // Create polygon features
                        return Object.values(locationGroups).flatMap(group => {
                            return group.map((entry, groupIndex) => {
                                const { item, index, fillColor, strokeColor } = entry;
                                const baseRadius = calculatePolygonSize(map);
                                const offset = calculatePointOffset(groupIndex, baseRadius * 0.5);
                                
                                const offsetLon = item.lon + offset.x;
                                const offsetLat = item.lat + offset.y;

                                return {
                                    type: 'Feature',
                                    properties: {
                                        id: index,
                                        ...item,
                                        fillColor,
                                        strokeColor
                                    },
                                    geometry: {
                                        type: 'Polygon',
                                        coordinates: [createPolygonCoordinates(map, offsetLon, offsetLat)]
                                    }
                                };
                            });
                        });
                    }

                    // Initial features
                    const features = updateFeatures();

                    // Add source with features
                    map.addSource('locations', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: features
                        }
                    });

                    // Add a layer for the polygons
                    map.addLayer({
                        id: 'location-polygons',
                        type: 'fill',
                        source: 'locations',
                        paint: {
                            'fill-color': ['get', 'fillColor'],
                            'fill-opacity': 0.6
                        }
                    });

                    // Add an outline layer for the polygons
                    map.addLayer({
                        id: 'location-polygons-outline',
                        type: 'line',
                        source: 'locations',
                        paint: {
                            'line-color': ['get', 'strokeColor'],
                            'line-width': 2
                        }
                    });

                    // Make tippyInstances available globally so the close button can access it
                    window.tippyInstances = {};

                    // Add click events to polygons
                    map.on('click', 'location-polygons', function(e) {
                        e.preventDefault(); // Prevent map click from triggering
                        if (e.features.length > 0) {
                            const feature = e.features[0];
                            const id = feature.properties.id;
                            highlightPolygon(map, id);
                            // Get click position
                            const clickX = e.point.x;
                            const clickY = e.point.y;
                            
                            // Create tooltip content with the ID for close button reference
                            const tooltipContent = document.createElement('div');
                            tooltipContent.innerHTML = createTooltipHTML(feature, id);
                            
                            // Create marker element to attach tooltip to
                            let marker = document.getElementById(`marker-${id}`);
                            if (!marker) {
                                marker = document.createElement('div');
                                marker.id = `marker-${id}`;
                                marker.style.position = 'absolute';
                                marker.style.top = `${clickY}px`;
                                marker.style.left = `${clickX}px`;
                                marker.style.width = '1px';
                                marker.style.height = '1px';
                                document.body.appendChild(marker);
                            }
                            
                            // Hide any existing tooltips first
                            Object.values(window.tippyInstances).forEach(instance => {
                                if (instance && instance.hide) {
                                    instance.hide();
                                }
                            });
                            
                            // Create tippy instance
                            setTimeout(() => {
                                // Make sure any previous instance is destroyed
                                if (window.tippyInstances[id] && window.tippyInstances[id].destroy) {
                                    window.tippyInstances[id].destroy();
                                }
                                
                                // Create new instance on the marker element
                                window.tippyInstances[id] = tippy(marker, {
                                    content: tooltipContent,
                                    allowHTML: true,
                                    interactive: true,
                                    theme: 'light',
                                    placement: 'top',
                                    trigger: 'manual',
                                    appendTo: document.body,
                                    showOnCreate: true,
                                    hideOnClick: false,
                                    interactiveBorder: 30
                                });
                                
                                // Show the tooltip
                                if (window.tippyInstances[id] && window.tippyInstances[id].show) {
                                    window.tippyInstances[id].show();
                                }
                            }, 0);
                        }
                    });

                    // Add click handlers for markers
                    window.locationMarkers?.forEach(({marker, id, properties}) => {
                        marker.getElement().addEventListener('click', (e) => {
                            e.preventDefault();
                            
                            highlightPolygon(map, id);
                            
                            const rect = marker.getElement().getBoundingClientRect();
                            const clickX = rect.left + rect.width/2;
                            const clickY = rect.top;
                            
                            const tooltipContent = document.createElement('div');
                            tooltipContent.innerHTML = createTooltipHTML({properties}, id);
                            
                            let markerEl = document.getElementById(`marker-${id}`);
                            if (!markerEl) {
                                markerEl = document.createElement('div');
                                markerEl.id = `marker-${id}`;
                                markerEl.style.position = 'absolute';
                                markerEl.style.top = `${clickY}px`;
                                markerEl.style.left = `${clickX}px`;
                                markerEl.style.width = '1px';
                                markerEl.style.height = '1px';
                                document.body.appendChild(markerEl);
                            }
                            
                            // Hide any existing tooltips
                            Object.values(window.tippyInstances).forEach(instance => {
                                if (instance && instance.hide) {
                                    instance.hide();
                                }
                            });
                            
                            setTimeout(() => {
                                if (window.tippyInstances[id]) {
                                    window.tippyInstances[id].destroy();
                                }
                                
                                window.tippyInstances[id] = tippy(markerEl, {
                                    content: tooltipContent,
                                    allowHTML: true,
                                    interactive: true,
                                    theme: 'light',
                                    placement: 'top',
                                    trigger: 'manual',
                                    appendTo: document.body,
                                    showOnCreate: true,
                                    hideOnClick: false,
                                    interactiveBorder: 30
                                });
                                
                                if (window.tippyInstances[id].show) {
                                    window.tippyInstances[id].show();
                                }
                            }, 0);
                        });
                    });

                    // Change cursor on polygon hover
                    map.on('mouseenter', 'location-polygons', function() {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    
                    map.on('mouseleave', 'location-polygons', function() {
                        map.getCanvas().style.cursor = '';
                    });

                    // Update tooltip positions when map moves
                    map.on('move', function() {
                        Object.values(window.tippyInstances).forEach(instance => {
                            if (instance && instance.state && instance.state.isVisible) {
                                instance.hide();
                            }
                        });
                    });
                    
                    // Update polygon sizes when zoom changes
                    map.on('zoom', function() {
                        // Update features with new polygon sizes
                        const updatedFeatures = updateFeatures();
                        
                        // Update the source data
                        map.getSource('locations').setData({
                            type: 'FeatureCollection',
                            features: updatedFeatures
                        });
                    });

                    // Add click handler for map to reset highlights when clicking elsewhere
                    map.on('click', (e) => {
                        if (!e.defaultPrevented) { // Only if not clicking on a polygon
                            highlightPolygon(map, -1); // Pass invalid index to reset all
                        }
                    });
                });
            })
            .catch(function(error) {
                console.error("Error loading the data:", error);
            });

        function toggleTabs() {
            const panel = document.getElementById('tabs-panel');
            const map = document.getElementById('map');
            const isHidden = panel.style.display === 'none' || !panel.style.display;
            
            panel.style.display = isHidden ? 'block' : 'none';
            map.classList.toggle('panel-visible');
            
            if (window.map) {
                window.map.resize();
            }
        }

        // Add tab switching functionality
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons and contents
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked button and corresponding content
                button.classList.add('active');
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });

        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('mobile-visible');
        }
    </script>
</body>
</html>